# v0.5.2 — Option 2: Meta-controller resilience (no-feasible fallback)

You are working in repo `Gatra-comparison` on top of tag `v0.5.1` (or current main if v0.5.1 is merged).

## Problem
`make run_morl_policy_quick` can fail with:
ValueError: No feasible candidates satisfy constraints
when meta-controller constraints (e.g., recall_min, alerts_per_1k_max) filter out all candidates.

## Goal
Make meta-selection NEVER hard-fail due to zero feasible candidates. Instead:
- Produce a best-effort selection using a deterministic fallback strategy
- Write diagnostics so audits/reviewers can see what happened
- Preserve strict typing (mypy) and ruff cleanliness
- Keep contract-only evaluation: no BigQuery calls in meta-selection tests

## Constraints
- Deterministic: use existing seed plumbing; stable tie-breakers.
- Backward compatible: if feasible set non-empty, behavior unchanged.
- CI-safe: tests must not require pyarrow and must not require BigQuery auth.
- Keep outputs format stable; only add new fields (do not rename existing ones).

## Deliverables

### A) meta_controller.yaml: new fallback block
Add:
fallback:
  mode: auto_relax | soft_constraints   # default auto_relax
  auto_relax:
    recall_min_steps: [0.60, 0.55, 0.50, 0.40]
    alerts_per_1k_max_steps: [30, 50, 80, 120]
    stop_on_first_feasible: true
  soft_constraints:
    lambda_recall: 5.0
    lambda_alerts: 0.05
  min_candidates: 1   # if still empty after relax, pick best by utility with a warning

### B) meta_controller.py: implement fallback
- Extract a function:
  select_with_constraints(
    candidates, constraints, selector, fallback_cfg, seed
  ) -> (selection, diagnostics)
- If initial feasible candidates empty:
  - auto_relax:
    try each relaxation step deterministically until feasible
  - soft_constraints:
    score all candidates with penalty; select max score
- Deterministic tie-break: if scores equal, choose smallest weight lexicographically or stable index order.

Diagnostics to return and persist:
- feasible_count_initial
- fallback_used, fallback_mode
- relaxation_trace (list of attempted constraints + feasible_count)
- final_constraints_used
- violated_constraints_summary (for final selection if still violates)

### C) Reporting artifacts updates
Update meta_selection_report.py to include a “Fallback” section:
- Whether fallback was used
- Relaxation trace table
- Final constraints used

Update meta_selection.json schema to include the new diagnostic keys.

### D) Makefile ergonomics
If make targets exist for meta-select, ensure they still work without changes.
No requirement to add new Make targets.

### E) Tests
Add tests that reproduce the failure and verify fallback:
1) test_meta_controller_fallback_autorelax.py
   - construct candidates where none meet recall_min=0.60, alerts_max=30
   - ensure with auto_relax enabled it relaxes to a step that yields feasible set
   - assert fallback_used true and final_constraints_used reflect relaxed values
2) test_meta_controller_fallback_soft_constraints.py
   - ensure soft-constraint selection returns a result and writes diagnostics
No BigQuery, no pyarrow.

### F) Docs
Update morl.md:
- Add short “When constraints are infeasible” note
- Explain fallback modes and how to adjust in meta_controller.yaml

## Commit plan (exact order)
1) feat(v0.5.2): add meta-controller fallback config + selection logic
2) test(v0.5.2): add fallback tests
3) docs(v0.5.2): document infeasible-constraint fallback

## Quality gate
Run:
- make format
- make lint
- make test
All must pass.

## PR
Create branch: v0.5.2-meta-controller-fallback
Open PR title: "v0.5.2: meta-controller fallback when constraints infeasible"
Include: what changed, why, and how to tune fallback modes.

Codex app / Codex in Cursor prompt

Paste this prompt (works in OpenAI’s Codex app and also inside Cursor Codex panel).
Implement codex_tasks/v0.5.2_option2_meta_controller_resilience.md exactly.
Create branch v0.5.2-meta-controller-fallback.
Follow the commit plan in order, run make format, make lint, make test, and ensure all pass.
If you want to refactor, do not—only touch what the spec requires unless CI forces changes.
